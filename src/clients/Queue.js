// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import Client from '../Client';

export default class Queue extends Client {
  constructor(options = {}) {
    super({
      baseUrl: 'https://queue.taskcluster.net/v1',
      exchangePrefix: '',
      ...options
    });
    this.task.entry = {type:'function',method:'get',route:'/task/<taskId>',query:[],args:['taskId'],name:'task',stability:'stable',output:true}; // eslint-disable-line
    this.status.entry = {type:'function',method:'get',route:'/task/<taskId>/status',query:[],args:['taskId'],name:'status',stability:'stable',output:true}; // eslint-disable-line
    this.listTaskGroup.entry = {type:'function',method:'get',route:'/task-group/<taskGroupId>/list',query:['continuationToken','limit'],args:['taskGroupId'],name:'listTaskGroup',stability:'stable',output:true}; // eslint-disable-line
    this.listDependentTasks.entry = {type:'function',method:'get',route:'/task/<taskId>/dependents',query:['continuationToken','limit'],args:['taskId'],name:'listDependentTasks',stability:'stable',output:true}; // eslint-disable-line
    this.createTask.entry = {type:'function',method:'put',route:'/task/<taskId>',query:[],args:['taskId'],name:'createTask',stability:'stable',scopes:{AllOf:[{'for':'scope','in':'scopes',each:'<scope>'},{'for':'route','in':'routes',each:'queue:route:<route>'},{AnyOf:[{AllOf:['queue:scheduler-id:<schedulerId>',{AnyOf:[{'for':'priority','in':'priorities',each:'queue:create-task:<priority>:<provisionerId>/<workerType>'}]}]},{'if':'legacyScopes',then:{AnyOf:['queue:create-task:<provisionerId>/<workerType>',{AllOf:['queue:define-task:<provisionerId>/<workerType>','queue:task-group-id:<schedulerId>/<taskGroupId>','queue:schedule-task:<schedulerId>/<taskGroupId>/<taskId>']}]}}]}]},input:true,output:true}; // eslint-disable-line
    this.defineTask.entry = {type:'function',method:'post',route:'/task/<taskId>/define',query:[],args:['taskId'],name:'defineTask',stability:'deprecated',scopes:{AllOf:[{'for':'scope','in':'scopes',each:'<scope>'},{'for':'route','in':'routes',each:'queue:route:<route>'},{AnyOf:[{AllOf:['queue:scheduler-id:<schedulerId>',{AnyOf:[{'for':'priority','in':'priorities',each:'queue:create-task:<priority>:<provisionerId>/<workerType>'}]}]},{'if':'legacyScopes',then:{AnyOf:['queue:define-task:<provisionerId>/<workerType>','queue:create-task:<provisionerId>/<workerType>',{AllOf:['queue:define-task:<provisionerId>/<workerType>','queue:task-group-id:<schedulerId>/<taskGroupId>']}]}}]}]},input:true,output:true}; // eslint-disable-line
    this.scheduleTask.entry = {type:'function',method:'post',route:'/task/<taskId>/schedule',query:[],args:['taskId'],name:'scheduleTask',stability:'stable',scopes:{AnyOf:['queue:schedule-task:<schedulerId>/<taskGroupId>/<taskId>',{AllOf:['queue:schedule-task','assume:scheduler-id:<schedulerId>/<taskGroupId>']}]},output:true}; // eslint-disable-line
    this.rerunTask.entry = {type:'function',method:'post',route:'/task/<taskId>/rerun',query:[],args:['taskId'],name:'rerunTask',stability:'deprecated',scopes:{AnyOf:['queue:rerun-task:<schedulerId>/<taskGroupId>/<taskId>',{AllOf:['queue:rerun-task','assume:scheduler-id:<schedulerId>/<taskGroupId>']}]},output:true}; // eslint-disable-line
    this.cancelTask.entry = {type:'function',method:'post',route:'/task/<taskId>/cancel',query:[],args:['taskId'],name:'cancelTask',stability:'stable',scopes:{AnyOf:['queue:cancel-task:<schedulerId>/<taskGroupId>/<taskId>',{AllOf:['queue:cancel-task','assume:scheduler-id:<schedulerId>/<taskGroupId>']}]},output:true}; // eslint-disable-line
    this.pollTaskUrls.entry = {type:'function',method:'get',route:'/poll-task-url/<provisionerId>/<workerType>',query:[],args:['provisionerId','workerType'],name:'pollTaskUrls',stability:'stable',scopes:{AnyOf:['queue:poll-task-urls:<provisionerId>/<workerType>',{AllOf:['queue:poll-task-urls','assume:worker-type:<provisionerId>/<workerType>']}]},output:true}; // eslint-disable-line
    this.claimWork.entry = {type:'function',method:'post',route:'/claim-work/<provisionerId>/<workerType>',query:[],args:['provisionerId','workerType'],name:'claimWork',stability:'stable',scopes:{AllOf:['queue:claim-work:<provisionerId>/<workerType>','queue:worker-id:<workerGroup>/<workerId>']},input:true,output:true}; // eslint-disable-line
    this.claimTask.entry = {type:'function',method:'post',route:'/task/<taskId>/runs/<runId>/claim',query:[],args:['taskId','runId'],name:'claimTask',stability:'stable',scopes:{AnyOf:[{AllOf:['queue:claim-task:<provisionerId>/<workerType>','queue:worker-id:<workerGroup>/<workerId>']},{AllOf:['queue:claim-task','assume:worker-type:<provisionerId>/<workerType>','assume:worker-id:<workerGroup>/<workerId>']}]},input:true,output:true}; // eslint-disable-line
    this.reclaimTask.entry = {type:'function',method:'post',route:'/task/<taskId>/runs/<runId>/reclaim',query:[],args:['taskId','runId'],name:'reclaimTask',stability:'stable',scopes:{AnyOf:['queue:reclaim-task:<taskId>/<runId>',{AllOf:['queue:claim-task','assume:worker-id:<workerGroup>/<workerId>']}]},output:true}; // eslint-disable-line
    this.reportCompleted.entry = {type:'function',method:'post',route:'/task/<taskId>/runs/<runId>/completed',query:[],args:['taskId','runId'],name:'reportCompleted',stability:'stable',scopes:{AnyOf:['queue:resolve-task:<taskId>/<runId>',{AllOf:['queue:resolve-task','assume:worker-id:<workerGroup>/<workerId>']}]},output:true}; // eslint-disable-line
    this.reportFailed.entry = {type:'function',method:'post',route:'/task/<taskId>/runs/<runId>/failed',query:[],args:['taskId','runId'],name:'reportFailed',stability:'stable',scopes:{AnyOf:['queue:resolve-task:<taskId>/<runId>',{AllOf:['queue:resolve-task','assume:worker-id:<workerGroup>/<workerId>']}]},output:true}; // eslint-disable-line
    this.reportException.entry = {type:'function',method:'post',route:'/task/<taskId>/runs/<runId>/exception',query:[],args:['taskId','runId'],name:'reportException',stability:'stable',scopes:{AnyOf:['queue:resolve-task:<taskId>/<runId>',{AllOf:['queue:resolve-task','assume:worker-id:<workerGroup>/<workerId>']}]},input:true,output:true}; // eslint-disable-line
    this.createArtifact.entry = {type:'function',method:'post',route:'/task/<taskId>/runs/<runId>/artifacts/<name>',query:[],args:['taskId','runId','name'],name:'createArtifact',stability:'stable',scopes:{AnyOf:['queue:create-artifact:<taskId>/<runId>',{AllOf:['queue:create-artifact:<name>','assume:worker-id:<workerGroup>/<workerId>']}]},input:true,output:true}; // eslint-disable-line
    this.completeArtifact.entry = {type:'function',method:'put',route:'/task/<taskId>/runs/<runId>/artifacts/<name>',query:[],args:['taskId','runId','name'],name:'completeArtifact',stability:'experimental',scopes:{AnyOf:['queue:create-artifact:<taskId>/<runId>',{AllOf:['queue:create-artifact:<name>','assume:worker-id:<workerGroup>/<workerId>']}]},input:true}; // eslint-disable-line
    this.getArtifact.entry = {type:'function',method:'get',route:'/task/<taskId>/runs/<runId>/artifacts/<name>',query:[],args:['taskId','runId','name'],name:'getArtifact',stability:'stable',scopes:{'if':'private',then:{AllOf:['queue:get-artifact:<name>']}}}; // eslint-disable-line
    this.getLatestArtifact.entry = {type:'function',method:'get',route:'/task/<taskId>/artifacts/<name>',query:[],args:['taskId','name'],name:'getLatestArtifact',stability:'stable',scopes:{'if':'private',then:{AllOf:['queue:get-artifact:<name>']}}}; // eslint-disable-line
    this.listArtifacts.entry = {type:'function',method:'get',route:'/task/<taskId>/runs/<runId>/artifacts',query:['continuationToken','limit'],args:['taskId','runId'],name:'listArtifacts',stability:'experimental',output:true}; // eslint-disable-line
    this.listLatestArtifacts.entry = {type:'function',method:'get',route:'/task/<taskId>/artifacts',query:['continuationToken','limit'],args:['taskId'],name:'listLatestArtifacts',stability:'experimental',output:true}; // eslint-disable-line
    this.listProvisioners.entry = {type:'function',method:'get',route:'/provisioners',query:['continuationToken','limit'],args:[],name:'listProvisioners',stability:'experimental',output:true}; // eslint-disable-line
    this.getProvisioner.entry = {type:'function',method:'get',route:'/provisioners/<provisionerId>',query:[],args:['provisionerId'],name:'getProvisioner',stability:'experimental',output:true}; // eslint-disable-line
    this.declareProvisioner.entry = {type:'function',method:'put',route:'/provisioners/<provisionerId>',query:[],args:['provisionerId'],name:'declareProvisioner',stability:'experimental',scopes:{AllOf:[{'for':'property','in':'properties',each:'queue:declare-provisioner:<provisionerId>#<property>'}]},input:true,output:true}; // eslint-disable-line
    this.pendingTasks.entry = {type:'function',method:'get',route:'/pending/<provisionerId>/<workerType>',query:[],args:['provisionerId','workerType'],name:'pendingTasks',stability:'stable',output:true}; // eslint-disable-line
    this.listWorkerTypes.entry = {type:'function',method:'get',route:'/provisioners/<provisionerId>/worker-types',query:['continuationToken','limit'],args:['provisionerId'],name:'listWorkerTypes',stability:'experimental',output:true}; // eslint-disable-line
    this.getWorkerType.entry = {type:'function',method:'get',route:'/provisioners/<provisionerId>/worker-types/<workerType>',query:[],args:['provisionerId','workerType'],name:'getWorkerType',stability:'experimental',output:true}; // eslint-disable-line
    this.declareWorkerType.entry = {type:'function',method:'put',route:'/provisioners/<provisionerId>/worker-types/<workerType>',query:[],args:['provisionerId','workerType'],name:'declareWorkerType',stability:'experimental',scopes:{AllOf:[{'for':'property','in':'properties',each:'queue:declare-worker-type:<provisionerId>/<workerType>#<property>'}]},input:true,output:true}; // eslint-disable-line
    this.listWorkers.entry = {type:'function',method:'get',route:'/provisioners/<provisionerId>/worker-types/<workerType>/workers',query:['continuationToken','limit','quarantined'],args:['provisionerId','workerType'],name:'listWorkers',stability:'experimental',output:true}; // eslint-disable-line
    this.getWorker.entry = {type:'function',method:'get',route:'/provisioners/<provisionerId>/worker-types/<workerType>/workers/<workerGroup>/<workerId>',query:[],args:['provisionerId','workerType','workerGroup','workerId'],name:'getWorker',stability:'experimental',output:true}; // eslint-disable-line
    this.quarantineWorker.entry = {type:'function',method:'put',route:'/provisioners/<provisionerId>/worker-types/<workerType>/workers/<workerGroup>/<workerId>',query:[],args:['provisionerId','workerType','workerGroup','workerId'],name:'quarantineWorker',stability:'experimental',scopes:{AllOf:['queue:quarantine-worker:<provisionerId>/<workerType>/<workerGroup>/<workerId>']},input:true,output:true}; // eslint-disable-line
    this.declareWorker.entry = {type:'function',method:'put',route:'/provisioners/<provisionerId>/worker-types/<workerType>/<workerGroup>/<workerId>',query:[],args:['provisionerId','workerType','workerGroup','workerId'],name:'declareWorker',stability:'experimental',scopes:{AllOf:[{'for':'property','in':'properties',each:'queue:declare-worker:<provisionerId>/<workerType>/<workerGroup>/<workerId>#<property>'}]},input:true,output:true}; // eslint-disable-line
    this.ping.entry = {type:'function',method:'get',route:'/ping',query:[],args:[],name:'ping',stability:'stable'}; // eslint-disable-line
  }

  // This end-point will return the task-definition. Notice that the task
  // definition may have been modified by queue, if an optional property is
  // not specified the queue may provide a default value.
  task(...args) {
    this.validate(this.task.entry, args);
    return this.request(this.task.entry, args);
  }

  // Get task status structure from `taskId`
  status(...args) {
    this.validate(this.status.entry, args);
    return this.request(this.status.entry, args);
  }

  // List tasks sharing the same `taskGroupId`.
  // As a task-group may contain an unbounded number of tasks, this end-point
  // may return a `continuationToken`. To continue listing tasks you must call
  // the `listTaskGroup` again with the `continuationToken` as the
  // query-string option `continuationToken`.
  // By default this end-point will try to return up to 1000 members in one
  // request. But it **may return less**, even if more tasks are available.
  // It may also return a `continuationToken` even though there are no more
  // results. However, you can only be sure to have seen all results if you
  // keep calling `listTaskGroup` with the last `continuationToken` until you
  // get a result without a `continuationToken`.
  // If you are not interested in listing all the members at once, you may
  // use the query-string option `limit` to return fewer.
  listTaskGroup(...args) {
    this.validate(this.listTaskGroup.entry, args);
    return this.request(this.listTaskGroup.entry, args);
  }

  // List tasks that depend on the given `taskId`.
  // As many tasks from different task-groups may dependent on a single tasks,
  // this end-point may return a `continuationToken`. To continue listing
  // tasks you must call `listDependentTasks` again with the
  // `continuationToken` as the query-string option `continuationToken`.
  // By default this end-point will try to return up to 1000 tasks in one
  // request. But it **may return less**, even if more tasks are available.
  // It may also return a `continuationToken` even though there are no more
  // results. However, you can only be sure to have seen all results if you
  // keep calling `listDependentTasks` with the last `continuationToken` until
  // you get a result without a `continuationToken`.
  // If you are not interested in listing all the tasks at once, you may
  // use the query-string option `limit` to return fewer.
  listDependentTasks(...args) {
    this.validate(this.listDependentTasks.entry, args);
    return this.request(this.listDependentTasks.entry, args);
  }

  // Create a new task, this is an **idempotent** operation, so repeat it if
  // you get an internal server error or network connection is dropped.
  // **Task `deadline´**, the deadline property can be no more than 5 days
  // into the future. This is to limit the amount of pending tasks not being
  // taken care of. Ideally, you should use a much shorter deadline.
  // **Task expiration**, the `expires` property must be greater than the
  // task `deadline`. If not provided it will default to `deadline` + one
  // year. Notice, that artifacts created by task must expire before the task.
  // **Task specific routing-keys**, using the `task.routes` property you may
  // define task specific routing-keys. If a task has a task specific
  // routing-key: `<route>`, then when the AMQP message about the task is
  // published, the message will be CC'ed with the routing-key:
  // `route.<route>`. This is useful if you want another component to listen
  // for completed tasks you have posted.  The caller must have scope
  // `queue:route:<route>` for each route.
  // **Dependencies**, any tasks referenced in `task.dependencies` must have
  // already been created at the time of this call.
  // **Important** Any scopes the task requires are also required for creating
  // the task. Please see the Request Payload (Task Definition) for details.
  createTask(...args) {
    this.validate(this.createTask.entry, args);
    return this.request(this.createTask.entry, args);
  }

  // **Deprecated**, this is the same as `createTask` with a **self-dependency**.
  // This is only present for legacy.
  defineTask(...args) {
    this.validate(this.defineTask.entry, args);
    return this.request(this.defineTask.entry, args);
  }

  // scheduleTask will schedule a task to be executed, even if it has
  // unresolved dependencies. A task would otherwise only be scheduled if
  // its dependencies were resolved.
  // This is useful if you have defined a task that depends on itself or on
  // some other task that has not been resolved, but you wish the task to be
  // scheduled immediately.
  // This will announce the task as pending and workers will be allowed to
  // claim it and resolve the task.
  // **Note** this operation is **idempotent** and will not fail or complain
  // if called with a `taskId` that is already scheduled, or even resolved.
  // To reschedule a task previously resolved, use `rerunTask`.
  scheduleTask(...args) {
    this.validate(this.scheduleTask.entry, args);
    return this.request(this.scheduleTask.entry, args);
  }

  // This method _reruns_ a previously resolved task, even if it was
  // _completed_. This is useful if your task completes unsuccessfully, and
  // you just want to run it from scratch again. This will also reset the
  // number of `retries` allowed.
  // Remember that `retries` in the task status counts the number of runs that
  // the queue have started because the worker stopped responding, for example
  // because a spot node died.
  // **Remark** this operation is idempotent, if you try to rerun a task that
  // is not either `failed` or `completed`, this operation will just return
  // the current task status.
  rerunTask(...args) {
    this.validate(this.rerunTask.entry, args);
    return this.request(this.rerunTask.entry, args);
  }

  // This method will cancel a task that is either `unscheduled`, `pending` or
  // `running`. It will resolve the current run as `exception` with
  // `reasonResolved` set to `canceled`. If the task isn't scheduled yet, ie.
  // it doesn't have any runs, an initial run will be added and resolved as
  // described above. Hence, after canceling a task, it cannot be scheduled
  // with `queue.scheduleTask`, but a new run can be created with
  // `queue.rerun`. These semantics is equivalent to calling
  // `queue.scheduleTask` immediately followed by `queue.cancelTask`.
  // **Remark** this operation is idempotent, if you try to cancel a task that
  // isn't `unscheduled`, `pending` or `running`, this operation will just
  // return the current task status.
  cancelTask(...args) {
    this.validate(this.cancelTask.entry, args);
    return this.request(this.cancelTask.entry, args);
  }

  // Get a signed URLs to get and delete messages from azure queue.
  // Once messages are polled from here, you can claim the referenced task
  // with `claimTask`, and afterwards you should always delete the message.
  pollTaskUrls(...args) {
    this.validate(this.pollTaskUrls.entry, args);
    return this.request(this.pollTaskUrls.entry, args);
  }

  // Claim any task, more to be added later... long polling up to 20s.
  claimWork(...args) {
    this.validate(this.claimWork.entry, args);
    return this.request(this.claimWork.entry, args);
  }

  // claim a task, more to be added later...
  claimTask(...args) {
    this.validate(this.claimTask.entry, args);
    return this.request(this.claimTask.entry, args);
  }

  // Refresh the claim for a specific `runId` for given `taskId`. This updates
  // the `takenUntil` property and returns a new set of temporary credentials
  // for performing requests on behalf of the task. These credentials should
  // be used in-place of the credentials returned by `claimWork`.
  // The `reclaimTask` requests serves to:
  //  * Postpone `takenUntil` preventing the queue from resolving
  //    `claim-expired`,
  //  * Refresh temporary credentials used for processing the task, and
  //  * Abort execution if the task/run have been resolved.
  // If the `takenUntil` timestamp is exceeded the queue will resolve the run
  // as _exception_ with reason `claim-expired`, and proceeded to retry to the
  // task. This ensures that tasks are retried, even if workers disappear
  // without warning.
  // If the task is resolved, this end-point will return `409` reporting
  // `RequestConflict`. This typically happens if the task have been canceled
  // or the `task.deadline` have been exceeded. If reclaiming fails, workers
  // should abort the task and forget about the given `runId`. There is no
  // need to resolve the run or upload artifacts.
  reclaimTask(...args) {
    this.validate(this.reclaimTask.entry, args);
    return this.request(this.reclaimTask.entry, args);
  }

  // Report a task completed, resolving the run as `completed`.
  reportCompleted(...args) {
    this.validate(this.reportCompleted.entry, args);
    return this.request(this.reportCompleted.entry, args);
  }

  // Report a run failed, resolving the run as `failed`. Use this to resolve
  // a run that failed because the task specific code behaved unexpectedly.
  // For example the task exited non-zero, or didn't produce expected output.
  // Do not use this if the task couldn't be run because if malformed
  // payload, or other unexpected condition. In these cases we have a task
  // exception, which should be reported with `reportException`.
  reportFailed(...args) {
    this.validate(this.reportFailed.entry, args);
    return this.request(this.reportFailed.entry, args);
  }

  // Resolve a run as _exception_. Generally, you will want to report tasks as
  // failed instead of exception. You should `reportException` if,
  //   * The `task.payload` is invalid,
  //   * Non-existent resources are referenced,
  //   * Declared actions cannot be executed due to unavailable resources,
  //   * The worker had to shutdown prematurely,
  //   * The worker experienced an unknown error, or,
  //   * The task explicitly requested a retry.
  // Do not use this to signal that some user-specified code crashed for any
  // reason specific to this code. If user-specific code hits a resource that
  // is temporarily unavailable worker should report task _failed_.
  reportException(...args) {
    this.validate(this.reportException.entry, args);
    return this.request(this.reportException.entry, args);
  }

  // This API end-point creates an artifact for a specific run of a task. This
  // should **only** be used by a worker currently operating on this task, or
  // from a process running within the task (ie. on the worker).
  // All artifacts must specify when they `expires`, the queue will
  // automatically take care of deleting artifacts past their
  // expiration point. This features makes it feasible to upload large
  // intermediate artifacts from data processing applications, as the
  // artifacts can be set to expire a few days later.
  // We currently support 3 different `storageType`s, each storage type have
  // slightly different features and in some cases difference semantics.
  // We also have 2 deprecated `storageType`s which are only maintained for
  // backwards compatiability and should not be used in new implementations
  // **Blob artifacts**, are useful for storing large files.  Currently, these
  // are all stored in S3 but there are facilities for adding support for other
  // backends in futre.  A call for this type of artifact must provide information
  // about the file which will be uploaded.  This includes sha256 sums and sizes.
  // This method will return a list of general form HTTP requests which are signed
  // by AWS S3 credentials managed by the Queue.  Once these requests are completed
  // the list of `ETag` values returned by the requests must be passed to the
  // queue `completeArtifact` method
  // **S3 artifacts**, DEPRECATED is useful for static files which will be
  // stored on S3. When creating an S3 artifact the queue will return a
  // pre-signed URL to which you can do a `PUT` request to upload your
  // artifact. Note that `PUT` request **must** specify the `content-length`
  // header and **must** give the `content-type` header the same value as in
  // the request to `createArtifact`.
  // **Azure artifacts**, DEPRECATED are stored in _Azure Blob Storage_ service
  // which given the consistency guarantees and API interface offered by Azure
  // is more suitable for artifacts that will be modified during the execution
  // of the task. For example docker-worker has a feature that persists the
  // task log to Azure Blob Storage every few seconds creating a somewhat
  // live log. A request to create an Azure artifact will return a URL
  // featuring a [Shared-Access-Signature](http://msdn.microsoft.com/en-us/library/azure/dn140256.aspx),
  // refer to MSDN for further information on how to use these.
  // **Warning: azure artifact is currently an experimental feature subject
  // to changes and data-drops.**
  // **Reference artifacts**, only consists of meta-data which the queue will
  // store for you. These artifacts really only have a `url` property and
  // when the artifact is requested the client will be redirect the URL
  // provided with a `303` (See Other) redirect. Please note that we cannot
  // delete artifacts you upload to other service, we can only delete the
  // reference to the artifact, when it expires.
  // **Error artifacts**, only consists of meta-data which the queue will
  // store for you. These artifacts are only meant to indicate that you the
  // worker or the task failed to generate a specific artifact, that you
  // would otherwise have uploaded. For example docker-worker will upload an
  // error artifact, if the file it was supposed to upload doesn't exists or
  // turns out to be a directory. Clients requesting an error artifact will
  // get a `403` (Forbidden) response. This is mainly designed to ensure that
  // dependent tasks can distinguish between artifacts that were suppose to
  // be generated and artifacts for which the name is misspelled.
  // **Artifact immutability**, generally speaking you cannot overwrite an
  // artifact when created. But if you repeat the request with the same
  // properties the request will succeed as the operation is idempotent.
  // This is useful if you need to refresh a signed URL while uploading.
  // Do not abuse this to overwrite artifacts created by another entity!
  // Such as worker-host overwriting artifact created by worker-code.
  // As a special case the `url` property on _reference artifacts_ can be
  // updated. You should only use this to update the `url` property for
  // reference artifacts your process has created.
  createArtifact(...args) {
    this.validate(this.createArtifact.entry, args);
    return this.request(this.createArtifact.entry, args);
  }

  // This endpoint finalises an upload done through the blob `storageType`.
  // The queue will ensure that the task/run is still allowing artifacts
  // to be uploaded.  For single-part S3 blob artifacts, this endpoint
  // will simply ensure the artifact is present in S3.  For multipart S3
  // artifacts, the endpoint will perform the commit step of the multipart
  // upload flow.  As the final step for both multi and single part artifacts,
  // the `present` entity field will be set to `true` to reflect that the
  // artifact is now present and a message published to pulse.  NOTE: This
  // endpoint *must* be called for all artifacts of storageType 'blob'
  completeArtifact(...args) {
    this.validate(this.completeArtifact.entry, args);
    return this.request(this.completeArtifact.entry, args);
  }

  // Get artifact by `<name>` from a specific run.
  // **Public Artifacts**, in-order to get an artifact you need the scope
  // `queue:get-artifact:<name>`, where `<name>` is the name of the artifact.
  // But if the artifact `name` starts with `public/`, authentication and
  // authorization is not necessary to fetch the artifact.
  // **API Clients**, this method will redirect you to the artifact, if it is
  // stored externally. Either way, the response may not be JSON. So API
  // client users might want to generate a signed URL for this end-point and
  // use that URL with a normal HTTP client.
  // **Caching**, artifacts may be cached in data centers closer to the
  // workers in-order to reduce bandwidth costs. This can lead to longer
  // response times. Caching can be skipped by setting the header
  // `x-taskcluster-skip-cache: true`, this should only be used for resources
  // where request volume is known to be low, and caching not useful.
  // (This feature may be disabled in the future, use is sparingly!)
  getArtifact(...args) {
    this.validate(this.getArtifact.entry, args);
    return this.request(this.getArtifact.entry, args);
  }

  // Get artifact by `<name>` from the last run of a task.
  // **Public Artifacts**, in-order to get an artifact you need the scope
  // `queue:get-artifact:<name>`, where `<name>` is the name of the artifact.
  // But if the artifact `name` starts with `public/`, authentication and
  // authorization is not necessary to fetch the artifact.
  // **API Clients**, this method will redirect you to the artifact, if it is
  // stored externally. Either way, the response may not be JSON. So API
  // client users might want to generate a signed URL for this end-point and
  // use that URL with a normal HTTP client.
  // **Remark**, this end-point is slightly slower than
  // `queue.getArtifact`, so consider that if you already know the `runId` of
  // the latest run. Otherwise, just us the most convenient API end-point.
  getLatestArtifact(...args) {
    this.validate(this.getLatestArtifact.entry, args);
    return this.request(this.getLatestArtifact.entry, args);
  }

  // Returns a list of artifacts and associated meta-data for a given run.
  // As a task may have many artifacts paging may be necessary. If this
  // end-point returns a `continuationToken`, you should call the end-point
  // again with the `continuationToken` as the query-string option:
  // `continuationToken`.
  // By default this end-point will list up-to 1000 artifacts in a single page
  // you may limit this with the query-string parameter `limit`.
  listArtifacts(...args) {
    this.validate(this.listArtifacts.entry, args);
    return this.request(this.listArtifacts.entry, args);
  }

  // Returns a list of artifacts and associated meta-data for the latest run
  // from the given task.
  // As a task may have many artifacts paging may be necessary. If this
  // end-point returns a `continuationToken`, you should call the end-point
  // again with the `continuationToken` as the query-string option:
  // `continuationToken`.
  // By default this end-point will list up-to 1000 artifacts in a single page
  // you may limit this with the query-string parameter `limit`.
  listLatestArtifacts(...args) {
    this.validate(this.listLatestArtifacts.entry, args);
    return this.request(this.listLatestArtifacts.entry, args);
  }

  // Get all active provisioners.
  // The term "provisioner" is taken broadly to mean anything with a provisionerId.
  // This does not necessarily mean there is an associated service performing any
  // provisioning activity.
  // The response is paged. If this end-point returns a `continuationToken`, you
  // should call the end-point again with the `continuationToken` as a query-string
  // option. By default this end-point will list up to 1000 provisioners in a single
  // page. You may limit this with the query-string parameter `limit`.
  listProvisioners(...args) {
    this.validate(this.listProvisioners.entry, args);
    return this.request(this.listProvisioners.entry, args);
  }

  // Get an active provisioner.
  // The term "provisioner" is taken broadly to mean anything with a provisionerId.
  // This does not necessarily mean there is an associated service performing any
  // provisioning activity.
  getProvisioner(...args) {
    this.validate(this.getProvisioner.entry, args);
    return this.request(this.getProvisioner.entry, args);
  }

  // Declare a provisioner, supplying some details about it.
  // `declareProvisioner` allows updating one or more properties of a provisioner as long as the required scopes are
  // possessed. For example, a request to update the `aws-provisioner-v1`
  // provisioner with a body `{description: 'This provisioner is great'}` would require you to have the scope
  // `queue:declare-provisioner:aws-provisioner-v1#description`.
  // The term "provisioner" is taken broadly to mean anything with a provisionerId.
  // This does not necessarily mean there is an associated service performing any
  // provisioning activity.
  declareProvisioner(...args) {
    this.validate(this.declareProvisioner.entry, args);
    return this.request(this.declareProvisioner.entry, args);
  }

  // Get an approximate number of pending tasks for the given `provisionerId`
  // and `workerType`.
  // The underlying Azure Storage Queues only promises to give us an estimate.
  // Furthermore, we cache the result in memory for 20 seconds. So consumers
  // should be no means expect this to be an accurate number.
  // It is, however, a solid estimate of the number of pending tasks.
  pendingTasks(...args) {
    this.validate(this.pendingTasks.entry, args);
    return this.request(this.pendingTasks.entry, args);
  }

  // Get all active worker-types for the given provisioner.
  // The response is paged. If this end-point returns a `continuationToken`, you
  // should call the end-point again with the `continuationToken` as a query-string
  // option. By default this end-point will list up to 1000 worker-types in a single
  // page. You may limit this with the query-string parameter `limit`.
  listWorkerTypes(...args) {
    this.validate(this.listWorkerTypes.entry, args);
    return this.request(this.listWorkerTypes.entry, args);
  }

  // Get a worker-type from a provisioner.
  getWorkerType(...args) {
    this.validate(this.getWorkerType.entry, args);
    return this.request(this.getWorkerType.entry, args);
  }

  // Declare a workerType, supplying some details about it.
  // `declareWorkerType` allows updating one or more properties of a worker-type as long as the required scopes are
  // possessed. For example, a request to update the `gecko-b-1-w2008` worker-type within the `aws-provisioner-v1`
  // provisioner with a body `{description: 'This worker type is great'}` would require you to have the scope
  // `queue:declare-worker-type:aws-provisioner-v1/gecko-b-1-w2008#description`.
  declareWorkerType(...args) {
    this.validate(this.declareWorkerType.entry, args);
    return this.request(this.declareWorkerType.entry, args);
  }

  // Get a list of all active workers of a workerType.
  // `listWorkers` allows a response to be filtered by quarantined and non quarantined workers.
  // To filter the query, you should call the end-point with `quarantined` as a query-string option with a
  // true or false value.
  // The response is paged. If this end-point returns a `continuationToken`, you
  // should call the end-point again with the `continuationToken` as a query-string
  // option. By default this end-point will list up to 1000 workers in a single
  // page. You may limit this with the query-string parameter `limit`.
  listWorkers(...args) {
    this.validate(this.listWorkers.entry, args);
    return this.request(this.listWorkers.entry, args);
  }

  // Get a worker from a worker-type.
  getWorker(...args) {
    this.validate(this.getWorker.entry, args);
    return this.request(this.getWorker.entry, args);
  }

  // Quarantine a worker
  quarantineWorker(...args) {
    this.validate(this.quarantineWorker.entry, args);
    return this.request(this.quarantineWorker.entry, args);
  }

  // Declare a worker, supplying some details about it.
  // `declareWorker` allows updating one or more properties of a worker as long as the required scopes are
  // possessed.
  declareWorker(...args) {
    this.validate(this.declareWorker.entry, args);
    return this.request(this.declareWorker.entry, args);
  }

  // Respond without doing anything.
  // This endpoint is used to check that the service is up.
  ping(...args) {
    this.validate(this.ping.entry, args);
    return this.request(this.ping.entry, args);
  }
}
